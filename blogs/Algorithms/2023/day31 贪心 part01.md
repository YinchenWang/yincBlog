---
title: Day31 贪心 part01
date: 2023-8-11
tags:
 - algorithms
 - 代码随想录
categories:
 - Algorithms
---
#  Day31 贪心 part01

### 贪心算法理论基础

贪心的本质是选择每一阶段的局部最优，从而达到全局最优。

**贪心的使用：** 

贪心没有固定的套路，验证能不能使用贪心最好的策略是举反例，**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心**

**贪心的一般解题步骤：**

- 将问题分解为若干个子问题。
- 找出合适的贪心策略。
- 求解每一个子问题的最优解。
- 将局部最优解堆叠成全局最优解。

### 分发饼干 leetcode 455

题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1
```

思路： 很简单，先排序胃口与饼干，让小的饼干先满足小胃口的即可。

```C++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int num = 0;    //满足总数也是胃口值的索引。
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        for(int i = 0; i < s.size(); i++)
        {
            if (num < g.size() && g[num] <= s[i])   num++;
        }
        return num;
    }
};
```

### 摆动序列 leetcode 376

题目：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**示例 1：**

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

思路：要求返回子序列中最长的摆动序列长度，则根据摆动序列的定义，记录数组中的波峰、波谷即可的最长序列长度。其中，数组两端各有一个波峰。有三种情况需要考虑：

- 上下有平坡 （preDiff == 0， cudDiff > || < 0)
- 首位元素    (两端记录)
- 单调有平坡。（preDiff只在有变动的地方更新）

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int preDiff = 0;    //前一个摆动
        int curDiff = 0;    //当前摆动
        int max = 1;        //摆动数量，由于数组两端默认有两个摆动，下方未计算数组末尾所以 max初始值为 1.
        for(int i = 0; i < nums.size() - 1; ++i)
        {
            curDiff = nums[i + 1] - nums[i];
            if((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0))
            {
                ++max;
                preDiff = curDiff; //只在有摆动的地方更新pre，避免了单调有平坡时误加摆动数量。
            }
        }
        return max;
    }
};
```

### 最大子数组和 leetcode 53

题目：给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

思路：要求的是连续子序例的最大和，所以一直遍历，**每当当前连续和小于0了，则将当前连续和设为1从下一个数重新开始计数**，每当sum>result了更新result。

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result= INT32_MIN;
        int sum = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
            if (sum > result)   result = sum;
            if (sum <= 0)    sum = 0;
        }
        return result;
    }
};
```

