---
title: Day38 动态规划 part01
date: 2023-8-18
tags:
 - algorithms
 - 代码随想录
categories:
 - Algorithms
---
#  Day38 动态规划 part01

### 动态规划理论基础

**什么是动态规划：** 

Dynamic programming 简称DP，如果某一问题有很多重叠的子问题，使用动态规划最有效。

动态规划中每一个状态是由上一个状态推导出来的（区别于贪心，没有状态推导）

**动态规划的解题步骤：**

- 确定DP数组以及下标含义
- 确定递推公式
- DP数组初始化
- 确定遍历顺序
- 打印DP数组

**动态规划debug：**

最好方式是将DP数组打印出来，看是否是按照思路推导的。

### 斐波那契数 leetcode 509

题目：**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。 

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

思路：

- 确定DP数组以及下标含义： dp[i]  ：第i个斐波那契数为dp[i]。
- 确定递推公式：  dp[i] = dp[i -1] + dp[i - 2];
- DP数组初始化:   dp[0] = 0, dp[1] = 1
- 确定遍历顺序:    从前向后
- 打印DP数组： 用于debug

```C++
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; ++i)
        {
            dp[i] = dp[i - 1]  + dp[i -2];
        }
        return dp[n];
    }
};
```

### 爬楼梯 leetcode 70

题目：假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶 
```

**提示：**

- `1 <= n <= 45`

思路：

- 确定DP数组以及下标含义： dp[i]  ：爬到i层楼梯有dp[i]种方法
- 确定递推公式：  dp[i] = (dp[i -1] + cost[i -1]) ||  (dp[i - 2] + dp[i - 2]); 要求取最小，因此 dp[i] =min （ (dp[i -1] + cost[i -1]) ， (dp[i - 2] + dp[i - 2])）
- DP数组初始化:   dp[0] = 0, dp[1] = 10
- 确定遍历顺序:    从前向后
- 打印DP数组： 用于debug

```C++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; ++i)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

### 使用最小花费爬楼梯 leetcode 746

题目：给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

思路：

- 确定DP数组以及下标含义： dp[i]  ：爬到i层楼梯所需要的cost为dp[i]。
- 确定递推公式：  爬一层有1种方法，二层有2种方法， 三层有dp[1] +dp[2]种，每一层都是由上一层的方法加上一层或者上上层的方法加上爬两层楼的方法，dp[i] = dp[i -1] + dp[i - 2];
- DP数组初始化:   dp[0] = 0, dp[1] = 0, 由题可知从0或者1开始消耗都为0；
- 确定遍历顺序:    从前向后
- 打印DP数组： 用于debug

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1);
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= cost.size(); ++i)
        {
            dp[i] = min((cost[i - 1] + dp[i - 1]),(cost[i - 2] + dp[i - 2]));
        }
        return dp[cost.size()];
    }
};
```

