(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{427:function(s,n,a){"use strict";a.r(n);var t=a(2),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day11-队列与栈-part02"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day11-队列与栈-part02"}},[s._v("#")]),s._v(" Day11 队列与栈 part02")]),s._v(" "),n("h3",{attrs:{id:"有效的括号-leetcode-20"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#有效的括号-leetcode-20"}},[s._v("#")]),s._v(" 有效的括号 leetcode 20")]),s._v(" "),n("p",[s._v("题目：给定一个只包括 "),n("code",[s._v("'('")]),s._v("，"),n("code",[s._v("')'")]),s._v("，"),n("code",[s._v("'{'")]),s._v("，"),n("code",[s._v("'}'")]),s._v("，"),n("code",[s._v("'['")]),s._v("，"),n("code",[s._v("']'")]),s._v(" 的字符串 "),n("code",[s._v("s")]),s._v(" ，判断字符串是否有效。")]),s._v(" "),n("p",[s._v("有效字符串需满足：")]),s._v(" "),n("ol",[n("li",[s._v("左括号必须用相同类型的右括号闭合。")]),s._v(" "),n("li",[s._v("左括号必须以正确的顺序闭合。")]),s._v(" "),n("li",[s._v("每个右括号都有一个对应的相同类型的左括号。")])]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：s = "()"\n输出：true\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("思路：使用栈来处理。考虑总共有几种不匹配情况。")]),s._v(" "),n("p",[s._v("1、长度为奇数，必然不匹配，false。\n2、遍历完所有的字符串之后，发现栈不为空，则存在不匹配，false。\n3、遍历字符串过程中发现不匹配字符，false。\n4、在遍历的过程中，栈已经为空而字符串没有遍历完，说明存在右括号不匹配的情况，false。")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class MyQueue {\npublic:\n    std::stack<int> stackIn;\n    std::stack<int> stackOut;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stackIn.push(x);\n    }\n    \n    int pop() {\n        if(stackOut.empty())\n        {\n            while(!stackIn.empty())\n            {\n                stackOut.push(stackIn.top());\n                stackIn.pop();\n            }\n        }\n        int res = stackOut.top();\n        stackOut.pop();\n        return res;\n    }\n    \n    int peek() {\n        int res = this->pop(); // 直接使用已有的pop函数\n        stackOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n        return res;\n    }\n    \n    bool empty() {\n        return stackIn.empty() && stackOut.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br")])]),n("h3",{attrs:{id:"删除字符串中的所有相邻重复项-leetcode-1047"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#删除字符串中的所有相邻重复项-leetcode-1047"}},[s._v("#")]),s._v(" 删除字符串中的所有相邻重复项 leetcode 1047")]),s._v(" "),n("p",[s._v("题目：给出由小写字母组成的字符串 "),n("code",[s._v("S")]),s._v("，"),n("strong",[s._v("重复项删除操作")]),s._v("会选择两个相邻且相同的字母，并删除它们。")]),s._v(" "),n("p",[s._v("在 S 上反复执行重复项删除操作，直到无法继续删除。")]),s._v(" "),n("p",[s._v("在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。")]),s._v(" "),n("p",[n("strong",[s._v("示例：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入："abbaca"\n输出："ca"\n解释：\n例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("思路：很简单的栈的应用，只要遍历字符串，在该 字符！=栈顶元素时压栈，相等是pop即可。 注意最后的结果字符串要进行反转！！！")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Solution {\npublic:\n    string removeDuplicates(string s) {\n        std::stack<char> st;\n        for(char S : s)\n        {\n            if(st.empty() || S != st.top())\n            {\n                st.push(S);\n            }\n            else\n            {\n                st.pop();\n            }\n        }\n        string res = "";\n        while( !st.empty())\n        {\n            res += st.top();\n            st.pop();\n        }\n        reverse (res.begin(), res.end()); // 此时字符串需要反转一下\n        return res;\n    }\n};\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br")])]),n("h3",{attrs:{id:"逆波兰表达式-leetcode-150"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#逆波兰表达式-leetcode-150"}},[s._v("#")]),s._v(" 逆波兰表达式 leetcode 150")]),s._v(" "),n("p",[s._v("逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。")]),s._v(" "),n("ul",[n("li",[s._v("平常使用的算式则是一种中缀表达式，如 "),n("code",[s._v("( 1 + 2 ) * ( 3 + 4 )")]),s._v(" 。")]),s._v(" "),n("li",[s._v("该算式的逆波兰表达式写法为 "),n("code",[s._v("( ( 1 2 + ) ( 3 4 + ) * )")])])]),s._v(" "),n("p",[s._v("逆波兰表达式主要有以下两个优点：")]),s._v(" "),n("ul",[n("li",[s._v("去掉括号后表达式无歧义，上式即便写成 "),n("code",[s._v("1 2 + 3 4 + *")]),s._v("也可以依据次序计算出正确结果。")]),s._v(" "),n("li",[s._v("适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中")])]),s._v(" "),n("p",[s._v("题目：给你一个字符串数组 "),n("code",[s._v("tokens")]),s._v(" ，表示一个根据 "),n("a",{attrs:{href:"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437",target:"_blank",rel:"noopener noreferrer"}},[s._v("逆波兰表示法"),n("OutboundLink")],1),s._v(" 表示的算术表达式。")]),s._v(" "),n("p",[s._v("请你计算该表达式。返回一个表示表达式值的整数。")]),s._v(" "),n("p",[n("strong",[s._v("注意：")])]),s._v(" "),n("ul",[n("li",[s._v("有效的算符为 "),n("code",[s._v("'+'")]),s._v("、"),n("code",[s._v("'-'")]),s._v("、"),n("code",[s._v("'*'")]),s._v(" 和 "),n("code",[s._v("'/'")]),s._v(" 。")]),s._v(" "),n("li",[s._v("每个操作数（运算对象）都可以是一个整数或者另一个表达式。")]),s._v(" "),n("li",[s._v("两个整数之间的除法总是 "),n("strong",[s._v("向零截断")]),s._v(" 。")]),s._v(" "),n("li",[s._v("表达式中不含除零运算。")]),s._v(" "),n("li",[s._v("输入是一个根据逆波兰表示法表示的算术表达式。")]),s._v(" "),n("li",[s._v("答案及所有中间计算结果可以用 "),n("strong",[s._v("32 位")]),s._v(" 整数表示。")])]),s._v(" "),n("p",[s._v("思路：遍历字符串，遇见数字则压栈，遇见运算符计算然后压栈。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        std::stack<long long> st;\n        for( int i = 0; i < tokens.size(); i ++)\n        {\n            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")\n            {\n                long long num1 = st.top();\n                st.pop();\n                long long num2 = st.top();\n                st.pop();\n                if (tokens[i] == "+") st.push(num2 + num1);\n                if (tokens[i] == "-") st.push(num2 - num1);\n                if (tokens[i] == "*") st.push(num2 * num1);\n                if (tokens[i] == "/") st.push(num2 / num1);\n            }\n            else\n            {\n                st.push(stoll(tokens[i]));  //stoll 将字符串转换为long long类型\n            }\n        }\n        int result = st.top();\n        st.pop();\n        return result;\n    }\n};\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);