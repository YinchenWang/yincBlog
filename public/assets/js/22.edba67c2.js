(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{431:function(s,n,e){"use strict";e.r(n);var t=e(2),r=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day14-二叉树-part01"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day14-二叉树-part01"}},[s._v("#")]),s._v(" Day14 二叉树 part01")]),s._v(" "),n("h3",{attrs:{id:"二叉树基础理论"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树基础理论"}},[s._v("#")]),s._v(" 二叉树基础理论")]),s._v(" "),n("h4",{attrs:{id:"定义二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义二叉树"}},[s._v("#")]),s._v(" 定义二叉树")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("struct TreeNode{\n  int val;\n  TreeNode * left;\n  TreeNode * right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL){}\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("h4",{attrs:{id:"二叉树种类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树种类"}},[s._v("#")]),s._v(" 二叉树种类：")]),s._v(" "),n("p",[n("strong",[s._v("满二叉树：")]),s._v(" 如果一颗二叉树只有度为0度结点和度为2度结点，并且度为0度结点在同一层上，则这颗二叉树为满二叉树。")]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png"}}),s._v(" "),n("p",[n("strong",[s._v("完全二叉树：")]),s._v(" 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。")]),s._v(" "),n("img",{staticStyle:{zoom:"30%"},attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png"}}),s._v(" "),n("p",[n("strong",[s._v("二叉搜索树：")]),s._v(" "),n("strong",[s._v("二叉搜索树是一个有序树")]),s._v("。")]),s._v(" "),n("ul",[n("li",[s._v("若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；")]),s._v(" "),n("li",[s._v("若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；")]),s._v(" "),n("li",[s._v("它的左、右子树也分别为二叉排序树")])]),s._v(" "),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png"}}),s._v(" "),n("p",[n("strong",[s._v("平衡二叉搜索树：")]),s._v(" 又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png",alt:""}})]),s._v(" "),n("p",[s._v("在C++中，"),n("strong",[s._v("map、set、multimap、multiset")]),s._v("的底层实现都是平衡二叉搜索树，所以它们的增删操锁时间时间复杂度为 "),n("strong",[s._v("logn")]),s._v("。")]),s._v(" "),n("h4",{attrs:{id:"二叉树的存储方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的存储方式"}},[s._v("#")]),s._v(" 二叉树的存储方式：")]),s._v(" "),n("p",[n("strong",[s._v("链式存储：")]),s._v(" "),n("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/2020092019554618.png",alt:""}})]),s._v(" "),n("p",[n("strong",[s._v("顺序存储：")]),s._v(" "),n("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20200920200429452.png",alt:""}})]),s._v(" "),n("p",[s._v("用数组来存储二叉树遍历：")]),s._v(" "),n("p",[n("strong",[s._v("如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。")])]),s._v(" "),n("h4",{attrs:{id:"二叉树遍历方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树遍历方式"}},[s._v("#")]),s._v(" 二叉树遍历方式")]),s._v(" "),n("p",[s._v("存在两种遍历方式，根据深度优先遍历的前中后序遍历法和根据广度优先遍历的层次遍历。")]),s._v(" "),n("h4",{attrs:{id:"前序遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前序遍历"}},[s._v("#")]),s._v(" 前序遍历")]),s._v(" "),n("p",[n("strong",[s._v("递归前序遍历：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void Traversal(TreeNode* cur, vector<int>& vec)\n    {\n        if(cur == NULL) return;\n        vec.push_back(cur -> val);\n        Traversal(cur -> left, vec);\n        Traversal(cur -> right, vec);\n    }\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> res;\n        Traversal(root, res);\n        return res;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("p",[n("strong",[s._v("迭代前序遍历：")])]),s._v(" "),n("p",[s._v("与递归方法不同的是，迭代法使用栈来模拟其遍历过程，首先压入根结点，然后将其弹出，接着先压入右孩子再压入左孩子，然后依次弹出，如此就得到了前序遍历的结果。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        stack<TreeNode*> st;\n        vector<int> result;\n        if (root == NULL) return result;\n        st.push(root);\n        while(!st.empty())\n        {\n            TreeNode* node = st.top();\n            st.pop();\n            result.push_back(node -> val);\n            if (node -> right) st.push(node -> right);\n            if (node -> left) st.push(node -> left);\n        }\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])]),n("h4",{attrs:{id:"中序遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#中序遍历"}},[s._v("#")]),s._v(" 中序遍历")]),s._v(" "),n("p",[n("strong",[s._v("递归中序遍历：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void Tarversal(TreeNode* cur, vector<int>& vec)\n    {\n        if(cur == NULL) return;\n        Tarversal(cur -> left, vec);\n        vec.push_back(cur -> val);\n        Tarversal(cur -> right, vec);\n\n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> res;\n        Tarversal(root, res);\n        return res;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])]),n("p",[n("strong",[s._v("迭代中序遍历：")])]),s._v(" "),n("p",[s._v("迭代的中序遍历与前序遍历代码不可通用，因为其顺序为左中右，因此这里使用cur指针来访问左孩子直到最底层，然后再进行操作。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n   vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        TreeNode* cur = root;\n        while (cur != NULL || !st.empty()) {\n            if (cur != NULL) { // 指针来访问节点，访问到最底层\n                st.push(cur); // 将访问的节点放进栈\n                cur = cur->left;                // 左\n            } else {\n                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）\n                st.pop();\n                result.push_back(cur->val);     // 中\n                cur = cur->right;               // 右\n            }\n        }\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br")])]),n("h4",{attrs:{id:"后序遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后序遍历"}},[s._v("#")]),s._v(" 后序遍历")]),s._v(" "),n("p",[n("strong",[s._v("递归后序遍历：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nvoid Tarversal(TreeNode* cur, vector<int>& vec)\n    {\n        if(cur == NULL) return;\n        Tarversal(cur -> left, vec);\n        Tarversal(cur -> right, vec);\n        vec.push_back(cur -> val);\n\n    }\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> res;\n        Tarversal(root, res);\n        return res;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])]),n("p",[n("strong",[s._v("迭代后序遍历：")])]),s._v(" "),n("p",[s._v("后序遍历顺序为左右中，将前序遍历代码更改为中右左，然后将结果数组反转一下就可（女少口阿！）")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nvector<int> postorderTraversal(TreeNode* root) {\n        stack<TreeNode*> st;\n        vector<int> result;\n        if (root == NULL) return result;\n        st.push(root);\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            result.push_back(node->val);\n            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）\n            if (node->right) st.push(node->right); // 空节点不入栈\n        }\n        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])])])}),[],!1,null,null,null);n.default=r.exports}}]);