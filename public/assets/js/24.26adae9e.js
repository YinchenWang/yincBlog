(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{431:function(n,e,s){"use strict";s.r(e);var t=s(2),a=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"day16-二叉树-part03"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day16-二叉树-part03"}},[n._v("#")]),n._v(" Day16 二叉树 part03")]),n._v(" "),e("p",[e("strong",[n._v("二叉树的深度：")]),n._v(" 指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）（通常用前序求）")]),n._v(" "),e("p",[e("strong",[n._v("二叉树的高度：")]),n._v(" 指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）（通常用后序求）")]),n._v(" "),e("h3",{attrs:{id:"二叉树的最大深度-leetcode-104"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最大深度-leetcode-104"}},[n._v("#")]),n._v(" 二叉树的最大深度 leetcode 104")]),n._v(" "),e("p",[n._v("题目：给定一个二叉树 "),e("code",[n._v("root")]),n._v(" ，返回其最大深度。")]),n._v(" "),e("p",[n._v("二叉树的 "),e("strong",[n._v("最大深度")]),n._v(" 是指从根节点到最远叶子节点的最长路径上的节点数。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,9,20,null,null,15,7]\n输出：3\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br")])]),e("p",[n._v("**思路1：**使用层序遍历，记录每一层的深度，遍历到最后即可。（有些复杂）")]),n._v(" "),e("div",{staticClass:"language-C++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        int depth = 0;\n        queue<TreeNode*> que;\n        que.push(root);\n        while(!que.empty()) {\n            int size = que.size();\n            depth++; // 记录深度\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n        }\n        return depth;\n    }\n};\n\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br")])]),e("p",[e("strong",[n._v("思路2:")]),n._v(" 由于二叉树根结点的高度就是二叉树的最大深度，所以使用后序遍历来求根结点的最大高度即可得出最大深度。")]),n._v(" "),e("div",{staticClass:"language-C++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int getDepth(TreeNode* node)\n    {\n        if(node == NULL) return 0;\n        int leftDepth = getDepth(node -> left);\n        int rightDepth = getDepth(node -> right);\n        int depth = 1 + max(leftDepth, rightDepth);\n        return depth;\n    }\n    int maxDepth(TreeNode* root) {\n        return getDepth(root);   \n    }\n};\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br")])]),e("h3",{attrs:{id:"二叉树的最小深度-leetcode-111"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最小深度-leetcode-111"}},[n._v("#")]),n._v(" 二叉树的最小深度 leetcode 111")]),n._v(" "),e("p",[n._v("题目：给定一个二叉树，找出其最小深度。")]),n._v(" "),e("p",[n._v("最小深度是"),e("strong",[n._v("从根节点到最近叶子节点")]),n._v("的最短路径上的"),e("strong",[n._v("节点数量")]),n._v("。")]),n._v(" "),e("p",[n._v("**说明：**叶子节点是指没有子节点的节点。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,9,20,null,null,15,7]\n输出：2\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br")])]),e("p",[n._v("思路：思路与求最大深度相同，不过是遍历过程中取每个的最小深度即可。要"),e("strong",[n._v("特别注意")]),n._v(" 最小深度是到叶子结点的结点数量，所以注意去除只有一个子树的情况！！！")]),n._v(" "),e("div",{staticClass:"language-C++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int getHeight(TreeNode* node)\n    {\n        if(node == NULL)    return 0;   //叶子结点的高度为0；\n        int leftHeight = getHeight(node -> left);   //左子树高度\n        int rightHeight = getHeight(node -> right); //右子树高度\n\n        if(node -> left == NULL && node -> right != NULL)   //左子树为空，不是叶子结点\n            return 1 + rightHeight;\n        if(node -> left != NULL && node -> right == NULL)   //右子树为空，不是叶子结点\n            return 1 + leftHeight;\n\n        int res = 1 + min(leftHeight, rightHeight);\n        return res;\n    }\n    int minDepth(TreeNode* root) {\n        return getHeight(root);\n    }\n};\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br")])]),e("h3",{attrs:{id:"完全二叉树的节点个数-leetcode-222"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树的节点个数-leetcode-222"}},[n._v("#")]),n._v(" 完全二叉树的节点个数 leetcode 222")]),n._v(" "),e("p",[n._v("题目：给你一棵 "),e("strong",[n._v("完全二叉树")]),n._v(" 的根节点 "),e("code",[n._v("root")]),n._v(" ，求出该树的节点个数。")]),n._v(" "),e("p",[e("a",{attrs:{href:"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[n._v("完全二叉树"),e("OutboundLink")],1),n._v(" 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 "),e("code",[n._v("h")]),n._v(" 层，则该层包含 "),e("code",[n._v("1~ 2h")]),n._v(" 个节点。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1,2,3,4,5,6]\n输出：6\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br")])]),e("p",[n._v("思路1：普通解法使用递归或者迭代进行遍历，记录数量即可。以下使用递归的后序遍历")]),n._v(" "),e("div",{staticClass:"language-c++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int getNum(TreeNode* node)\n    {\n        if(node == NULL) return 0;\n        int leftNum = getNum(node -> left);\n        int rightNum = getNum(node -> right);\n        int num = 1 + leftNum + rightNum;\n        return num;\n    }\n    int countNodes(TreeNode* root) {\n        return getNum(root);\n    }\n};\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br")])]),e("p",[n._v("思路2：根据完全二叉树的特性求解。完全二叉树只有两种情况，满二叉树和最后一层叶子没有满。对于满二叉树可以直接使用2^n -1 来求结点数量。")]),n._v(" "),e("p",[n._v("判断完全二叉树是否为满二叉树直接遍历左右子树，如果值相等则为满二叉树否则不是（完全二叉树不存在中间结点为空的情况）")]),n._v(" "),e("div",{staticClass:"language-C++ line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n\n    int countNodes(TreeNode* root) {\n        if (root == nullptr) return 0;\n        TreeNode* left = root->left;\n        TreeNode* right = root->right;\n        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便\n        while (left) {  // 求左子树深度\n            left = left->left;\n            leftDepth++;\n        }\n        while (right) { // 求右子树深度\n            right = right->right;\n            rightDepth++;\n        }\n        if (leftDepth == rightDepth) {\n            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0\n        }\n        return countNodes(root->left) + countNodes(root->right) + 1;\n    }\n};\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br"),e("span",{staticClass:"line-number"},[n._v("27")]),e("br"),e("span",{staticClass:"line-number"},[n._v("28")]),e("br"),e("span",{staticClass:"line-number"},[n._v("29")]),e("br"),e("span",{staticClass:"line-number"},[n._v("30")]),e("br"),e("span",{staticClass:"line-number"},[n._v("31")]),e("br"),e("span",{staticClass:"line-number"},[n._v("32")]),e("br"),e("span",{staticClass:"line-number"},[n._v("33")]),e("br")])])])}),[],!1,null,null,null);e.default=a.exports}}]);