(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{436:function(e,s,n){"use strict";n.r(s);var t=n(2),a=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"day15-二叉树-part02"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#day15-二叉树-part02"}},[e._v("#")]),e._v(" Day15 二叉树 part02")]),e._v(" "),s("h3",{attrs:{id:"二叉树层序遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树层序遍历"}},[e._v("#")]),e._v(" 二叉树层序遍历")]),e._v(" "),s("p",[e._v("二叉树的层序遍历和图当中的广度优先搜索相同。")]),e._v(" "),s("h3",{attrs:{id:"二叉树的层序遍历-leetcode-102"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的层序遍历-leetcode-102"}},[e._v("#")]),e._v(" 二叉树的层序遍历 leetcode 102")]),e._v(" "),s("p",[e._v("题目：给你二叉树的根节点 "),s("code",[e._v("root")]),e._v(" ，返回其节点值的 "),s("strong",[e._v("层序遍历")]),e._v(" 。 （即逐层地，从左到右访问所有节点）。")]),e._v(" "),s("p",[s("strong",[e._v("示例 1：")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("思路：由题，使用广度优先搜索的想法，问题难点在存储其结点以及孩子。使用队列进行辅助，用size记录每一层结点的个数，每次循环size个结点，弹出其结点并且将其孩子加入队列即可。")]),e._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        queue<TreeNode*> que;\n        vector<vector<int>> result;\n        if(root != NULL) que.push(root);\n        while(!que.empty())\n        {\n            int size = que.size();\n            vector<int> res;\n            while(size--)\n            {\n                TreeNode* node = que.front();\n                res.push_back(node -> val);\n                que.pop();\n                if(node -> left) que.push(node -> left);\n                if(node -> right) que.push(node -> right);\n            }\n            result.push_back(res);\n        }\n        return result;\n    }\n};\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br")])]),s("h3",{attrs:{id:"二叉树的层序遍历ii-leetcode-107"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的层序遍历ii-leetcode-107"}},[e._v("#")]),e._v(" 二叉树的层序遍历II leetcode 107")]),e._v(" "),s("p",[e._v("题目：给你二叉树的根节点 "),s("code",[e._v("root")]),e._v(" ，返回其节点值 "),s("strong",[e._v("自底向上的层序遍历")]),e._v(" 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）")]),e._v(" "),s("p",[s("strong",[e._v("示例 1：")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("输入：root = [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("思路：正常使用层序遍历，最后将result数组反转一下即可。")]),e._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        queue<TreeNode*> que;\n        vector<vector<int>> result;\n        if(root != NULL) que.push(root);\n        while(!que.empty())\n        {\n            int size = que.size();\n            vector<int> res;\n            while(size--)\n            {\n                TreeNode* node = que.front();\n                res.push_back(node -> val);\n                que.pop();\n                if(node -> left) que.push(node -> left);\n                if(node -> right) que.push(node -> right);\n            }\n            result.push_back(res);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br")])]),s("h3",{attrs:{id:"二叉树的右视图-leetcode-199"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的右视图-leetcode-199"}},[e._v("#")]),e._v(" 二叉树的右视图 leetcode 199")]),e._v(" "),s("p",[e._v("题目：给定一个二叉树的 "),s("strong",[e._v("根节点")]),e._v(" "),s("code",[e._v("root")]),e._v("，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。")]),e._v(" "),s("p",[s("strong",[e._v("示例 1:")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("思路：层序遍历，每当遇到当前层的最右侧结点，将其存入数组即可。")]),e._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        queue<TreeNode*> que;\n        vector<int> result;\n        if(root != NULL) que.push(root);\n        while(!que.empty())\n        {\n            int size = que.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = que.front();\n                que.pop();\n                if (i == (size - 1)) result.push_back(node->val); // 将每一层的最后元素放入result数组中\n                if (node->left) que.push(node->left);\n                if (node->right) que.push(node->right);\n            }\n        }\n        return result;\n    }\n};\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br")])]),s("h3",{attrs:{id:"翻转二叉树-letcode-226"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#翻转二叉树-letcode-226"}},[e._v("#")]),e._v(" 翻转二叉树 letcode 226")]),e._v(" "),s("p",[e._v("题目：给你一棵二叉树的根节点 "),s("code",[e._v("root")]),e._v(" ，翻转这棵二叉树，并返回其根节点。")]),e._v(" "),s("p",[s("strong",[e._v("示例 1：")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("思路：")]),e._v(" "),s("p",[e._v("二叉树的翻转只需要在遍历的过程中交换左右两个孩子的指针即可全部翻转。注意不要使用中序遍历，因为会翻转多次。")]),e._v(" "),s("p",[s("strong",[e._v("递归法：")])]),e._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) return root;\n        swap(root->left, root->right);  // 中\n        invertTree(root->left);         // 左\n        invertTree(root->right);        // 右\n        return root;\n    }\n};\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])]),s("p",[s("strong",[e._v("迭代法：")])]),e._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == NULL) return root;\n        std::stack<TreeNode*> st;\n        st.push(root);\n        while(!st.empty())\n        {\n            TreeNode* node = st.top();              // 中\n            st.pop();\n            swap(node->left, node->right);\n            if(node->right) st.push(node->right);   // 右\n            if(node->left) st.push(node->left);     // 左\n        }\n        return root;\n    }\n};\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br")])]),s("h3",{attrs:{id:"对称二叉树-leetcode-101"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对称二叉树-leetcode-101"}},[e._v("#")]),e._v(" 对称二叉树 leetcode 101")]),e._v(" "),s("p",[e._v("题目：给你一个二叉树的根节点 "),s("code",[e._v("root")]),e._v(" ， 检查它是否轴对称。")]),e._v(" "),s("p",[s("strong",[e._v("示例 1：")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg",alt:"img"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("输入：root = [1,2,2,3,4,4,3]\n输出：true\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("思路：判断一个二叉树是否对称其实就是判断根结点的两个子树是否可以相互翻转。（一开始使用层序遍历配合栈的思路是错的，没有考虑值相等但不同位置的情况）")]),e._v(" "),s("p",[e._v("对于两个子树能否翻转的判断要使用后序遍历！ 先判断孩子是否相等，然后判断父结点是否相等。左子树使用正常的后序遍历（左右中）右子树使用变形的后序遍历（右左中）。然后一对比即可。")]),e._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool compare(TreeNode* left, TreeNode* right)\n    {\t\t//左右孩子的五种情况\n        if(left == NULL && right != NULL)   return false;\n        else if(left != NULL && right == NULL) return false;\n        else if(left == NULL && right == NULL) return true;\n        else if(left -> val != right -> val) return false;\n      \telse{\n        //以下情况，左右结点不为空且值相等，进入递归，判断下一层\n        \tbool outside = compare(left -> left, right -> right);   //判断两颗子树的外侧是否一致\n        \tbool inside = compare(left -> right, right -> left);    //判断两颗子树的内侧是否一致\n        \treturn outside && inside;\n        }\n    }\n    bool isSymmetric(TreeNode* root) {\n        if(root == NULL) return true;\n        return compare(root -> left, root -> right);\n    }\n};\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br")])])])}),[],!1,null,null,null);s.default=a.exports}}]);