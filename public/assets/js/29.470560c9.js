(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{431:function(s,n,e){"use strict";e.r(n);var t=e(2),a=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day21-二叉树-part07"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day21-二叉树-part07"}},[s._v("#")]),s._v(" Day21 二叉树 part07")]),s._v(" "),n("p",[n("strong",[s._v("二叉树的深度：")]),s._v(" 指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）（通常用前序求）")]),s._v(" "),n("p",[n("strong",[s._v("二叉树的高度：")]),s._v(" 指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）（通常用后序求）")]),s._v(" "),n("h3",{attrs:{id:"二叉搜索树的最小绝对差-leetcode-530"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树的最小绝对差-leetcode-530"}},[s._v("#")]),s._v(" 二叉搜索树的最小绝对差 leetcode 530")]),s._v(" "),n("p",[s._v("题目：给你一个二叉搜索树的根节点 "),n("code",[s._v("root")]),s._v(" ，返回 "),n("strong",[s._v("树中任意两不同节点值之间的最小差值")]),s._v(" 。")]),s._v(" "),n("p",[s._v("差值是一个正数，其数值等于两值之差的绝对值。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：root = [4,2,6,1,3]\n输出：1\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("思路：本题最直观的想法是将树转换为有序数组再进行比较。（可以但开销大）")]),s._v(" "),n("p",[s._v("使用双指针，在中序遍历中寻找差值即可。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int res = INT_MAX;\n    TreeNode* pre = NULL;\npublic:\n    void traversal(TreeNode* cur)\n    {\n        if(cur == NULL) return;\n        traversal(cur -> left);\n        if(pre != NULL)\n        {\n            res = min(res, cur -> val - pre -> val);\n        }\n        pre = cur;\n        traversal(cur -> right);\n    }\n    int getMinimumDifference(TreeNode* root) {\n        traversal(root);\n        return res;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br")])]),n("h3",{attrs:{id:"二叉树中的众数-leetcode-501"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树中的众数-leetcode-501"}},[s._v("#")]),s._v(" 二叉树中的众数 leetcode 501")]),s._v(" "),n("p",[s._v("题目：给你一个含重复值的二叉搜索树（BST）的根节点 "),n("code",[s._v("root")]),s._v(" ，找出并返回 BST 中的所有 "),n("a",{attrs:{href:"https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796",target:"_blank",rel:"noopener noreferrer"}},[s._v("众数"),n("OutboundLink")],1),s._v("（即，出现频率最高的元素）。")]),s._v(" "),n("p",[s._v("如果树中有不止一个众数，可以按 "),n("strong",[s._v("任意顺序")]),s._v(" 返回。")]),s._v(" "),n("p",[s._v("假定 BST 满足如下定义：")]),s._v(" "),n("ul",[n("li",[s._v("结点左子树中所含节点的值 "),n("strong",[s._v("小于等于")]),s._v(" 当前节点的值")]),s._v(" "),n("li",[s._v("结点右子树中所含节点的值 "),n("strong",[s._v("大于等于")]),s._v(" 当前节点的值")]),s._v(" "),n("li",[s._v("左子树和右子树都是二叉搜索树")])]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：root = [1,null,2,2]\n输出：[2]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("思路：第一想法遍历数，再使用哈希法求众数。")]),s._v(" "),n("p",[s._v("由于这是一个二叉搜索树，有序，所以可以使用双指针通过一次遍历就得到所有众数。使用中序遍历，每次统计到count > maxCount时，将结果集清空然后加入新的数。如果找到count == maxCount则将该数加入结果集。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate: \n    TreeNode* pre;\n    int count {0};\n    int maxCount {0};\n    vector<int> res;\npublic:\n    void traversal(TreeNode* cur)\n    {\n        if(cur == NULL) return;\n        traversal(cur -> left);\n        if(pre == NULL) count = 1;\n        else if(pre -> val == cur -> val)    count++;\n        else count = 1;\n        pre = cur;\n\n        if(count == maxCount)   res.push_back(cur -> val);\n        if(count > maxCount)\n        {\n            maxCount = count;\n            res.clear();\n            res.push_back(cur -> val);\n        }\n        traversal(cur -> right);\n    }\n    vector<int> findMode(TreeNode* root) {\n        traversal(root);\n        return res;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br")])]),n("h3",{attrs:{id:"二叉树的最近公共祖先-leetcode-236"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最近公共祖先-leetcode-236"}},[s._v("#")]),s._v(" 二叉树的最近公共祖先 leetcode 236")]),s._v(" "),n("p",[s._v("题目：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。")]),s._v(" "),n("p",[n("a",{attrs:{href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[s._v("百度百科"),n("OutboundLink")],1),s._v("中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),n("strong",[s._v("一个节点也可以是它自己的祖先")]),s._v("）。”")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：要查找公共祖先，所以自底向上查找，使用后序遍历。某个节点为p,q的公共祖先有两种情况：")]),s._v(" "),n("ol",[n("li",[s._v("p, q分别为该节点左右子树上的节点")]),s._v(" "),n("li",[s._v("p, q 为父子关系")])]),s._v(" "),n("p",[s._v("当遍历过程中遇到p或q时将其返回即可。")]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL) return NULL;\n        if(root == p || root == q) return root;\n        TreeNode * left = lowestCommonAncestor(root -> left, p, q);\n        TreeNode * right = lowestCommonAncestor(root -> right, p, q);\n\n        if(left != NULL && right != NULL) return root;\t//p q为root的左右子树的节点\n        if(left == NULL && right != NULL) return right; //p q都在root的右孩子的子树上且为父子关系\n        if(left != NULL && right == NULL) return left; //p q都在root的左孩子的子树上且为父子关系\n\n        return NULL;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br")])])])}),[],!1,null,null,null);n.default=a.exports}}]);