(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{437:function(s,n,e){"use strict";e.r(n);var t=e(2),a=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day22-二叉树-part08"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day22-二叉树-part08"}},[s._v("#")]),s._v(" Day22 二叉树 part08")]),s._v(" "),n("p",[n("strong",[s._v("二叉树的深度：")]),s._v(" 指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）（通常用前序求）")]),s._v(" "),n("p",[n("strong",[s._v("二叉树的高度：")]),s._v(" 指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）（通常用后序求）")]),s._v(" "),n("h3",{attrs:{id:"二叉搜索树的最近公共祖先-leetcode-235"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树的最近公共祖先-leetcode-235"}},[s._v("#")]),s._v(" 二叉搜索树的最近公共祖先 leetcode 235")]),s._v(" "),n("p",[s._v("题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。")]),s._v(" "),n("p",[n("a",{attrs:{href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[s._v("百度百科"),n("OutboundLink")],1),s._v("中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),n("strong",[s._v("一个节点也可以是它自己的祖先")]),s._v("）。”")]),s._v(" "),n("p",[s._v("例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]")]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png",alt:"img"}})]),s._v(" "),n("p",[n("strong",[s._v("示例 1:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：本题使用二叉树的最近公共祖先方法可解，不过由于本题是二叉搜索树，所以利用其特性能够更快的解决。当当前值大于两个节点的值时搜索左子树，小于时搜索右子树。其他情况则当前节点就是最近公共祖先！如此，能够快速解题。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == NULL)    return NULL;\n        if(root -> val > p -> val && root -> val > q -> val)\n        {\n            TreeNode * left = lowestCommonAncestor(root -> left, p, q);\n            if(left != NULL)    return left;\n        }\n\n        if(root -> val < p -> val && root -> val < q -> val)\n        {\n            TreeNode * right = lowestCommonAncestor(root -> right, p, q);\n            if(right != NULL)   return right;\n        }\n        return root;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br")])]),n("h3",{attrs:{id:"二叉搜索树中的插入操作-leetcode-701"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树中的插入操作-leetcode-701"}},[s._v("#")]),s._v(" "),n("strong",[s._v("二叉搜索树中的插入操作")]),s._v("  leetcode 701")]),s._v(" "),n("p",[s._v("题目：给定二叉搜索树（BST）的根节点 "),n("code",[s._v("root")]),s._v(" 和要插入树中的值 "),n("code",[s._v("value")]),s._v(" ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 "),n("strong",[s._v("保证")]),s._v(" ，新值和原始二叉搜索树中的任意节点值都不同。")]),s._v(" "),n("p",[n("strong",[s._v("注意")]),s._v("，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 "),n("strong",[s._v("任意有效的结果")]),s._v(" 。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：root = [4,2,7,1,3], val = 5\n输出：[4,2,7,1,3,5]\n解释：另一个满足题目要求可以通过的树是：\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg",alt:""}})]),s._v(" "),n("p",[s._v("思路：不用考虑那些有的没的，因为是二叉搜索树所以插入一个值的时候直接找对应子树的叶子结点插入就完事了！！！")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if(root == NULL)    return new TreeNode(val);\n        if(root -> val > val)\n        {\n            root -> left = insertIntoBST(root -> left, val);\n        }\n        if(root -> val < val)\n        {\n            root -> right = insertIntoBST(root -> right, val);\n        }\n        return root;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br")])]),n("h3",{attrs:{id:"删除二叉搜索树的节点-leetcode-450"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#删除二叉搜索树的节点-leetcode-450"}},[s._v("#")]),s._v(" 删除二叉搜索树的节点 leetcode 450")]),s._v(" "),n("p",[s._v("题目：给定一个二叉搜索树的根节点 "),n("strong",[s._v("root")]),s._v(" 和一个值 "),n("strong",[s._v("key")]),s._v("，删除二叉搜索树中的 "),n("strong",[s._v("key")]),s._v(" 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。")]),s._v(" "),n("p",[s._v("一般来说，删除节点可分为两个步骤：")]),s._v(" "),n("ol",[n("li",[s._v("首先找到需要删除的节点；")]),s._v(" "),n("li",[s._v("如果找到了，删除它。")])]),s._v(" "),n("p",[n("strong",[s._v("示例 1:")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：root = [5,3,6,2,4,null,7], key = 3\n输出：[5,4,6,2,null,null,7]\n解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg",alt:""}})]),s._v(" "),n("p",[s._v("思路：删除节点有五种情况要考虑")]),s._v(" "),n("ol",[n("li",[s._v("没找到 ： 返回空。")]),s._v(" "),n("li",[s._v("删除的是叶子结点 ： 直接删除")]),s._v(" "),n("li",[s._v("删除的结点只有左孩子 ： 将左孩子作为父结点孩子。")]),s._v(" "),n("li",[s._v("删除的结点只有右孩子 ： 将右孩子作为父结点孩子。")]),s._v(" "),n("li",[s._v("删除节点有两个孩子 ： 将左子树或者右子树作为父结点孩子，另一个子连接到继承的子树的最右孩子或者最左孩子。")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == nullptr) return root;\n        if(root -> val == key)\n        {\n            if (root -> left == nullptr && root -> right == nullptr)\n            {\n                delete root;\n                return nullptr;\n            }\n            else if(root -> left == nullptr)\n            {\n                auto retNode = root -> right;\n                delete root;\n                return retNode;\n            }\n            else if(root -> right == nullptr)\n            {\n                auto retNode = root -> left;\n                delete root;\n                return retNode;\n            }\n            else\n            {\n                TreeNode * cur = root -> right;\n                while(cur -> left != nullptr)\n                {\n                    cur = cur -> left;\n                }\n                cur -> left = root -> left;\n                TreeNode * tmp = root;\n                root = root -> right;\n                delete tmp;\n                return root;\n            }\n        }\n        if(root -> val > key)   root -> left = deleteNode(root -> left, key);\n        if(root -> val < key)   root -> right = deleteNode(root -> right, key);\n        return root;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br")])])])}),[],!1,null,null,null);n.default=a.exports}}]);