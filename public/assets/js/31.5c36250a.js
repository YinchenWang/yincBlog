(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{436:function(s,n,a){"use strict";a.r(n);var t=a(2),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day24-回溯-part01"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day24-回溯-part01"}},[s._v("#")]),s._v(" Day24 回溯 part01")]),s._v(" "),n("h3",{attrs:{id:"回溯算法理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法理论基础"}},[s._v("#")]),s._v(" 回溯算法理论基础")]),s._v(" "),n("p",[s._v("回溯的本质是穷举！穷举所有可能，然后选出想要的答案")]),s._v(" "),n("p",[n("strong",[s._v("解决的问题：")])]),s._v(" "),n("ul",[n("li",[s._v("组合问题: N个数里按照一定规则找出K个数的集合")]),s._v(" "),n("li",[s._v("切割问题：一个字符串按一定规则右几种切割方式")]),s._v(" "),n("li",[s._v("子集问题：一个N个数的集合里有多少种符合条件的子集")]),s._v(" "),n("li",[s._v("排列问题：N个数按一定规则全排列，有几种排列方式")]),s._v(" "),n("li",[s._v("棋盘问题：N皇后、解数独。。。")])]),s._v(" "),n("p",[n("strong",[s._v("理解回溯：")])]),s._v(" "),n("p",[s._v("回溯法可抽象的理解为树形问题")]),s._v(" "),n("p",[s._v("因为回溯法的解决都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就是树的深度。")]),s._v(" "),n("p",[n("strong",[s._v("回溯法模版：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void backtracking(参数)\n{\n  if (终止条件)\n  {\n    存放结果;\n    return;\n  }\n  \n  for(选择：本层集合中元素(书中节点孩子的数量就是集合的大小))\n  {\n    处理节点；\n    backtracking(路径，选则列表);\t//递归\n    回溯，撤销处理结果；\n  }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("h3",{attrs:{id:"组合-leetcode-77"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组合-leetcode-77"}},[s._v("#")]),s._v(" 组合 leetcode 77")]),s._v(" "),n("p",[s._v("题目：给定两个整数 "),n("code",[s._v("n")]),s._v(" 和 "),n("code",[s._v("k")]),s._v("，返回范围 "),n("code",[s._v("[1, n]")]),s._v(" 中所有可能的 "),n("code",[s._v("k")]),s._v(" 个数的组合。")]),s._v(" "),n("p",[s._v("你可以按 "),n("strong",[s._v("任何顺序")]),s._v(" 返回答案。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：n = 4, k = 2\n输出：\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("思路：经典回溯问题，排列组合问题，每次回溯递归后，集合要小一位。path.size() == k 时达到叶子节点。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    vector<int> path;\n    vector<vector<int>> result;\n\n    void backtracking(int n, int k, int startIndex)\n    {\n        if(path.size() == k) \n        {\n            result.push_back(path);\n            startIndex++;\n            return;\n        }\n\n        for(int i = startIndex; i <= n; i++)\n        {\n            path.push_back(i);\n            backtracking(n, k, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        backtracking(n, k, 1);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])]),n("p",[n("strong",[s._v("剪枝：")])]),s._v(" "),n("p",[s._v("上方代码是遍历整个抽象树来查询符合条件的组合，实际上，当递归中剩余元素的个数小于 K的时候，剩下就全部不符合要求了，可以直接舍弃。优化如下：")]),s._v(" "),n("ol",[n("li",[s._v("已经选择的元素个数：path.size();")]),s._v(" "),n("li",[s._v("还需要的元素个数为: k - path.size();")]),s._v(" "),n("li",[s._v("在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历（该数之后开始都不符合要求）")])]),s._v(" "),n("p",[s._v("为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。")]),s._v(" "),n("p",[s._v("( [x, n]的数组长度起码应该是k-path.size()才有继续搜索的可能， 那么就有 n-x+1 = k-path.size()  ， 解方程得 x = n+1 - (k-path.size()), 而且这个x是可以作为起点往下搜的 也就是for(i = s; i<=x; i++) 这里的x是可以取到的)")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    vector<int> path;\n    vector<vector<int>> result;\n\n    void backtracking(int n, int k, int startIndex)\n    {\n        if(path.size() == k) \n        {\n            result.push_back(path);\n            startIndex++;\n            return;\n        }\n\n        for(int i = startIndex; i <= n - (k - path.size()) + 1; i++)\n        {\n            path.push_back(i);\n            backtracking(n, k, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        backtracking(n, k, 1);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);