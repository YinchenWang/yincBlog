(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{438:function(s,n,a){"use strict";a.r(n);var t=a(2),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day27-回溯-part03"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day27-回溯-part03"}},[s._v("#")]),s._v(" Day27 回溯 part03")]),s._v(" "),n("h3",{attrs:{id:"回溯算法理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法理论基础"}},[s._v("#")]),s._v(" 回溯算法理论基础")]),s._v(" "),n("p",[s._v("回溯的本质是穷举！穷举所有可能，然后选出想要的答案")]),s._v(" "),n("p",[n("strong",[s._v("解决的问题：")])]),s._v(" "),n("ul",[n("li",[s._v("组合问题: N个数里按照一定规则找出K个数的集合")]),s._v(" "),n("li",[s._v("切割问题：一个字符串按一定规则右几种切割方式")]),s._v(" "),n("li",[s._v("子集问题：一个N个数的集合里有多少种符合条件的子集")]),s._v(" "),n("li",[s._v("排列问题：N个数按一定规则全排列，有几种排列方式")]),s._v(" "),n("li",[s._v("棋盘问题：N皇后、解数独。。。")])]),s._v(" "),n("p",[n("strong",[s._v("理解回溯：")])]),s._v(" "),n("p",[s._v("回溯法可抽象的理解为树形问题")]),s._v(" "),n("p",[s._v("因为回溯法的解决都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就是树的深度。")]),s._v(" "),n("p",[n("strong",[s._v("回溯法模版：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void backtracking(参数)\n{\n  if (终止条件)\n  {\n    存放结果;\n    return;\n  }\n  \n  for(选择：本层集合中元素(书中节点孩子的数量就是集合的大小))\n  {\n    处理节点；\n    backtracking(路径，选则列表);\t//递归\n    回溯，撤销处理结果；\n  }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("h3",{attrs:{id:"组合总和-leetcode-39"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组合总和-leetcode-39"}},[s._v("#")]),s._v(" 组合总和 leetcode 39")]),s._v(" "),n("p",[s._v("题目：给你一个 "),n("strong",[s._v("无重复元素")]),s._v(" 的整数数组 "),n("code",[s._v("candidates")]),s._v(" 和一个目标整数 "),n("code",[s._v("target")]),s._v(" ，找出 "),n("code",[s._v("candidates")]),s._v(" 中可以使数字和为目标数 "),n("code",[s._v("target")]),s._v(" 的 所有 "),n("strong",[s._v("不同组合")]),s._v(" ，并以列表形式返回。你可以按 "),n("strong",[s._v("任意顺序")]),s._v(" 返回这些组合。")]),s._v(" "),n("p",[n("code",[s._v("candidates")]),s._v(" 中的 "),n("strong",[s._v("同一个")]),s._v(" 数字可以 "),n("strong",[s._v("无限制重复被选取")]),s._v(" 。如果至少一个数字的被选数量不同，则两种组合是不同的。")]),s._v(" "),n("p",[s._v("对于给定的输入，保证和为 "),n("code",[s._v("target")]),s._v(" 的不同组合数少于 "),n("code",[s._v("150")]),s._v(" 个。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：candidates = [2,3,6,7], target = 7\n输出：[[2,2,3],[7]]\n解释：\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("思路：本题与之前的组合总和相似，唯一区别是可重复使用元素，所以只需要更改startIndex为 i 即可")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    vector<int> path;\n    vector<vector<int>> result;\n\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)\n    {\n        if(sum > target)    return;\n        if(sum == target)  \n        {\n            result.push_back(path);\n            return;\n        }\n\n        for(int i = startIndex; i < candidates.size(); i++)\n        {\n            path.push_back(candidates[i]);\n            sum += candidates[i];\n            backtracking(candidates, target, sum, i);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        backtracking(candidates, target, 0, 0);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])]),n("p",[n("strong",[s._v("剪枝：")]),s._v(" 对数组先进行一个排序，这样当在一个序列中找到sum > target时，后序的就不需要再遍历了")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    vector<int> path;\n    vector<vector<int>> result;\n\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex)\n    {\n        if(sum > target)    return;\n        if(sum == target)  \n        {\n            result.push_back(path);\n            return;\n        }\n\n        for(int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)\n        {\n            path.push_back(candidates[i]);\n            sum += candidates[i];\n            backtracking(candidates, target, sum, i);\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0, 0);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br")])]),n("h3",{attrs:{id:"组合总和ii-leetcode-40"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组合总和ii-leetcode-40"}},[s._v("#")]),s._v(" 组合总和II leetcode 40")]),s._v(" "),n("p",[s._v("题目：给定一个候选人编号的集合 "),n("code",[s._v("candidates")]),s._v(" 和一个目标数 "),n("code",[s._v("target")]),s._v(" ，找出 "),n("code",[s._v("candidates")]),s._v(" 中所有可以使数字和为 "),n("code",[s._v("target")]),s._v(" 的组合。")]),s._v(" "),n("p",[n("code",[s._v("candidates")]),s._v(" 中的每个数字在每个组合中只能使用 "),n("strong",[s._v("一次")]),s._v(" 。")]),s._v(" "),n("p",[s._v("**注意：**解集不能包含重复的组合。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: candidates = [10,1,2,7,6,1,5], target = 8,\n输出:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("思路：本题与其他题的区别在于：")]),s._v(" "),n("ol",[n("li",[s._v("最终的结果数组里不能有重复的序列。")]),s._v(" "),n("li",[s._v("candidates数组中的每个元素只能用一次。")])]),s._v(" "),n("p",[s._v("首先需要对candidates数组进行排序，这样才能保证相同元素都是相邻的，便于剪枝。在遍历的过程中需要记录当前节点已被使用。")]),s._v(" "),n("p",[s._v("为了确保最终结果没有重复序列，需要对树层进行去重：当某个数值被使用过后，在后序的遍历中就跳过相同的数值，因为在第一个数进行递归的过程中已经找到了一个序列。")]),s._v(" "),n("p",[s._v("树层去重逻辑："),n("strong",[s._v("如果"),n("code",[s._v("candidates[i] == candidates[i - 1]")]),s._v(" 并且 "),n("code",[s._v("used[i - 1] == false")]),s._v("，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]")]),s._v("。")]),s._v(" "),n("p",[s._v("（为什么 used[i - 1] == false 就是同一树层呢，因为同一树层，used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。而 used[i - 1] == true，说明是进入下一层递归，去下一个数）")]),s._v(" "),n("p",[n("strong",[s._v("本题同时也需要在for循环中去重，否则某个用例会TLE！！！！")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    vector<int> path;\n    vector<vector<int>> result;\n\n    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used)\n    {\n        if(sum == target)\n        {\n            result.push_back(path);\n            return;\n        }\n        for(int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) // sum + candidates[i] <= target去重\n        {\n            if(i > 0 && candidates[i] == candidates[i - 1] && used[i-1] == false)   continue;\t//树层去重。\n            path.push_back(candidates[i]);\n            sum += candidates[i];\n            used[i] = true;\n            backtracking(candidates, target, sum, i + 1, used);\n            used[i] = false;\n            sum -= candidates[i];\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<bool> used(candidates.size(), false);\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0, 0, used);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br")])]),n("h3",{attrs:{id:"分割回文串-leetcode-131"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分割回文串-leetcode-131"}},[s._v("#")]),s._v(" 分割回文串 leetcode 131")]),s._v(" "),n("p",[s._v("题目：给你一个字符串 "),n("code",[s._v("s")]),s._v("，请你将 "),n("code",[s._v("s")]),s._v(" 分割成一些子串，使每个子串都是 "),n("strong",[s._v("回文串")]),s._v(" 。返回 "),n("code",[s._v("s")]),s._v(" 所有可能的分割方案。")]),s._v(" "),n("p",[n("strong",[s._v("回文串")]),s._v(" 是正着读和反着读都一样的字符串。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：s = "aab"\n输出：[["a","a","b"],["aa","b"]]\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("strong",[s._v("示例 2：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：s = "a"\n输出：[["a"]]\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("strong",[s._v("提示：")])]),s._v(" "),n("ul",[n("li",[n("code",[s._v("1 <= s.length <= 16")])]),s._v(" "),n("li",[n("code",[s._v("s")]),s._v(" 仅由小写英文字母组成")])]),s._v(" "),n("p",[s._v("思路：本题首先需要有一个判断回文的方法，其次是进行切割。由于题目要求每个子串都满足回文，所以遍历过程中遇见不满足条件的直接进入到下一个循环。")]),s._v(" "),n("p",[n("strong",[s._v("递归循环中如何截取子串：")])]),s._v(" "),n("p",[s._v("在"),n("code",[s._v("for (int i = startIndex; i < s.size(); i++)")]),s._v("循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。")]),s._v(" "),n("p",[s._v("首先判断这个子串是不是回文，如果是回文，就加入在"),n("code",[s._v("vector<string> path")]),s._v("中，path用来记录切割过的回文子串。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\n    private:\n    vector<string> path;\n    vector<vector<string>> result;\n\n    bool isPalindorme(const string& s, int start, int end)\n    {\n        for(int i = start, j = end; i < j; i++, j--)\n        {\n            if(s[i] != s[j])    return false;\n        }\n        return true;\n    }\n\n    void backtracking(const string& s, int startIndex)\n    {\n        if(startIndex >= s.size())  //切割位置大于等于s长度时代表找到了一个满足要求的切割方式\n        {\n            result.push_back(path);\n            return;\n        }\n\n        for(int i = startIndex; i < s.size(); i++)\n        {\n            if(isPalindorme(s, startIndex, i)) // 当前子串长度为(startIndex，i)\n            {\n                // 获取[startIndex,i]在s中的子串\n                string str = s.substr(startIndex, i - startIndex + 1);\n                path.push_back(str);\n            }\n            else    continue;       //不是回文串，没必要继续切割\n            backtracking(s, i + 1);\n            path.pop_back();\n        }\n    }\npublic:\n    vector<vector<string>> partition(string s) {\n        backtracking(s, 0);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);