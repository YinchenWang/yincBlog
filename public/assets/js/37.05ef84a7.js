(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{444:function(s,n,a){"use strict";a.r(n);var t=a(2),r=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day30-回溯-part06"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day30-回溯-part06"}},[s._v("#")]),s._v(" Day30 回溯 part06")]),s._v(" "),n("h3",{attrs:{id:"回溯算法理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回溯算法理论基础"}},[s._v("#")]),s._v(" 回溯算法理论基础")]),s._v(" "),n("p",[s._v("回溯的本质是穷举！穷举所有可能，然后选出想要的答案")]),s._v(" "),n("p",[n("strong",[s._v("解决的问题：")])]),s._v(" "),n("ul",[n("li",[s._v("组合问题: N个数里按照一定规则找出K个数的集合")]),s._v(" "),n("li",[s._v("切割问题：一个字符串按一定规则右几种切割方式")]),s._v(" "),n("li",[s._v("子集问题：一个N个数的集合里有多少种符合条件的子集")]),s._v(" "),n("li",[s._v("排列问题：N个数按一定规则全排列，有几种排列方式")]),s._v(" "),n("li",[s._v("棋盘问题：N皇后、解数独。。。")])]),s._v(" "),n("p",[n("strong",[s._v("理解回溯：")])]),s._v(" "),n("p",[s._v("回溯法可抽象的理解为树形问题")]),s._v(" "),n("p",[s._v("因为回溯法的解决都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就是树的深度。")]),s._v(" "),n("p",[n("strong",[s._v("回溯法模版：")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void backtracking(参数)\n{\n  if (终止条件)\n  {\n    存放结果;\n    return;\n  }\n  \n  for(选择：本层集合中元素(书中节点孩子的数量就是集合的大小))\n  {\n    处理节点；\n    backtracking(路径，选则列表);\t//递归\n    回溯，撤销处理结果；\n  }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br")])]),n("h3",{attrs:{id:"重新安排行程-leetcode-332"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重新安排行程-leetcode-332"}},[s._v("#")]),s._v(" 重新安排行程 leetcode 332")]),s._v(" "),n("p",[s._v("题目：给你一份航线列表 "),n("code",[s._v("tickets")]),s._v(" ，其中 "),n("code",[s._v("tickets[i] = [fromi, toi]")]),s._v(" 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。")]),s._v(" "),n("p",[s._v("所有这些机票都属于一个从 "),n("code",[s._v("JFK")]),s._v("（肯尼迪国际机场）出发的先生，所以该行程必须从 "),n("code",[s._v("JFK")]),s._v(" 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。")]),s._v(" "),n("ul",[n("li",[s._v("例如，行程 "),n("code",[s._v('["JFK", "LGA"]')]),s._v(" 与 "),n("code",[s._v('["JFK", "LGB"]')]),s._v(" 相比就更小，排序更靠前。")])]),s._v(" "),n("p",[s._v("假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]\n输出：["JFK","MUC","LHR","SFO","SJC"]\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("思路： 挺难，思路大概了解了 写不出来 放弃了")]),s._v(" "),n("h3",{attrs:{id:"n皇后-leetcode-51"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#n皇后-leetcode-51"}},[s._v("#")]),s._v(" N皇后 leetcode 51")]),s._v(" "),n("p",[s._v("题目：按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。")]),s._v(" "),n("p",[n("strong",[s._v("n 皇后问题")]),s._v(" 研究的是如何将 "),n("code",[s._v("n")]),s._v(" 个皇后放置在 "),n("code",[s._v("n×n")]),s._v(" 的棋盘上，并且使皇后彼此之间不能相互攻击。")]),s._v(" "),n("p",[s._v("给你一个整数 "),n("code",[s._v("n")]),s._v(" ，返回所有不同的 "),n("strong",[s._v("n 皇后问题")]),s._v(" 的解决方案。")]),s._v(" "),n("p",[s._v("每一种解法包含一个不同的 "),n("strong",[s._v("n 皇后问题")]),s._v(" 的棋子放置方案，该方案中 "),n("code",[s._v("'Q'")]),s._v(" 和 "),n("code",[s._v("'.'")]),s._v(" 分别代表了皇后和空位。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：n = 4\n输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：相对来说简单些，很容易理解，在每次放棋子之后进行判断就行了。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    vector<vector<string>> result;\n\n    bool isValid(int row, int col, vector<string> chessboard, int n)\n    {\n        // 检查列\n        for (int i = 0; i < row; i++) \n        { // 这是一个剪枝\n            if (chessboard[i][col] == 'Q')  return false;\n        }\n        // 检查 45度角是否有皇后\n        for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) \n        {\n            if (chessboard[i][j] == 'Q')    return false;\n        }\n    // 检查 135度角是否有皇后\n        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) \n        {\n            if (chessboard[i][j] == 'Q')    return false;\n        }\n        return true;\n    }\n\n    void backtracking(int n, int row, vector<string>& chessboard)\n    {\n        if(row == n)\n        {\n            result.push_back(chessboard);\n            return;\n        }\n\n        for(int col = 0; col < n ; col++)\n        {\n            if(isValid(row, col, chessboard, n))\n            {\n                chessboard[row][col] = 'Q';\n                backtracking(n, row + 1, chessboard);\n                chessboard[row][col] = '.';\n            }\n        }\n    }\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        std::vector<std::string> chessboard(n, std::string(n, '.'));\n        backtracking(n, 0, chessboard);\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br")])]),n("h3",{attrs:{id:"解数独-leetcode-37"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解数独-leetcode-37"}},[s._v("#")]),s._v(" 解数独 leetcode 37")]),s._v(" "),n("p",[s._v("题目：编写一个程序，通过填充空格来解决数独问题。")]),s._v(" "),n("p",[s._v("数独的解法需 "),n("strong",[s._v("遵循如下规则")]),s._v("：")]),s._v(" "),n("ol",[n("li",[s._v("数字 "),n("code",[s._v("1-9")]),s._v(" 在每一行只能出现一次。")]),s._v(" "),n("li",[s._v("数字 "),n("code",[s._v("1-9")]),s._v(" 在每一列只能出现一次。")]),s._v(" "),n("li",[s._v("数字 "),n("code",[s._v("1-9")]),s._v(" 在每一个以粗实线分隔的 "),n("code",[s._v("3x3")]),s._v(" 宫内只能出现一次。（请参考示例图）")])]),s._v(" "),n("p",[s._v("数独部分空格内已填入了数字，空白格用 "),n("code",[s._v("'.'")]),s._v(" 表示。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\n输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]\n解释：输入的数独如上图所示，唯一有效的解决方案如下所示：\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：主要是棋盘检验与二维递归。 自己写的TLE了 笑死")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\nbool backtracking(vector<vector<char>>& board) {\n    for (int i = 0; i < board.size(); i++) {        // 遍历行\n        for (int j = 0; j < board[0].size(); j++) { // 遍历列\n            if (board[i][j] == '.') {\n                for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适\n                    if (isValid(i, j, k, board)) {\n                        board[i][j] = k;                // 放置k\n                        if (backtracking(board)) return true; // 如果找到合适一组立刻返回\n                        board[i][j] = '.';              // 回溯，撤销k\n                    }\n                }\n                return false;  // 9个数都试完了，都不行，那么就返回false\n            }\n        }\n    }\n    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了\n}\nbool isValid(int row, int col, char val, vector<vector<char>>& board) {\n    \n    for (int j = 0; j < 9; j++) { // 判断列里是否重复\n        if (board[j][col] == val) {\n            return false;\n        }\n    }\n\n    for (int i = 0; i < 9; i++) { // 判断行里是否重复\n        if (board[row][i] == val) {\n            return false;\n        }\n    }\n    int startRow = (row / 3) * 3;\n    int startCol = (col / 3) * 3;\n    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复\n        for (int j = startCol; j < startCol + 3; j++) {\n            if (board[i][j] == val ) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        backtracking(board);\n    }\n};\n\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br")])])])}),[],!1,null,null,null);n.default=r.exports}}]);