(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{441:function(s,n,a){"use strict";a.r(n);var e=a(2),t=Object(e.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day31-贪心-part01"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day31-贪心-part01"}},[s._v("#")]),s._v(" Day31 贪心 part01")]),s._v(" "),n("h3",{attrs:{id:"贪心算法理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法理论基础"}},[s._v("#")]),s._v(" 贪心算法理论基础")]),s._v(" "),n("p",[s._v("贪心的本质是选择每一阶段的局部最优，从而达到全局最优。")]),s._v(" "),n("p",[n("strong",[s._v("贪心的使用：")])]),s._v(" "),n("p",[s._v("贪心没有固定的套路，验证能不能使用贪心最好的策略是举反例，"),n("strong",[s._v("刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心")])]),s._v(" "),n("p",[n("strong",[s._v("贪心的一般解题步骤：")])]),s._v(" "),n("ul",[n("li",[s._v("将问题分解为若干个子问题。")]),s._v(" "),n("li",[s._v("找出合适的贪心策略。")]),s._v(" "),n("li",[s._v("求解每一个子问题的最优解。")]),s._v(" "),n("li",[s._v("将局部最优解堆叠成全局最优解。")])]),s._v(" "),n("h3",{attrs:{id:"分发饼干-leetcode-455"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分发饼干-leetcode-455"}},[s._v("#")]),s._v(" 分发饼干 leetcode 455")]),s._v(" "),n("p",[s._v("题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。")]),s._v(" "),n("p",[s._v("对每个孩子 "),n("code",[s._v("i")]),s._v("，都有一个胃口值 "),n("code",[s._v("g[i]")]),s._v("，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 "),n("code",[s._v("j")]),s._v("，都有一个尺寸 "),n("code",[s._v("s[j]")]),s._v(" 。如果 "),n("code",[s._v("s[j] >= g[i]")]),s._v("，我们可以将这个饼干 "),n("code",[s._v("j")]),s._v(" 分配给孩子 "),n("code",[s._v("i")]),s._v(" ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: g = [1,2,3], s = [1,1]\n输出: 1\n解释: \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("思路： 很简单，先排序胃口与饼干，让小的饼干先满足小胃口的即可。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        int num = 0;    //满足总数也是胃口值的索引。\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        for(int i = 0; i < s.size(); i++)\n        {\n            if (num < g.size() && g[num] <= s[i])   num++;\n        }\n        return num;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("h3",{attrs:{id:"摆动序列-leetcode-376"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#摆动序列-leetcode-376"}},[s._v("#")]),s._v(" 摆动序列 leetcode 376")]),s._v(" "),n("p",[s._v("题目：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。")]),s._v(" "),n("ul",[n("li",[s._v("例如， "),n("code",[s._v("[1, 7, 4, 9, 2, 5]")]),s._v(" 是一个 "),n("strong",[s._v("摆动序列")]),s._v(" ，因为差值 "),n("code",[s._v("(6, -3, 5, -7, 3)")]),s._v(" 是正负交替出现的。")]),s._v(" "),n("li",[s._v("相反，"),n("code",[s._v("[1, 4, 7, 2, 5]")]),s._v(" 和 "),n("code",[s._v("[1, 7, 4, 5, 5]")]),s._v(" 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。")])]),s._v(" "),n("p",[n("strong",[s._v("子序列")]),s._v(" 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。")]),s._v(" "),n("p",[s._v("给你一个整数数组 "),n("code",[s._v("nums")]),s._v(" ，返回 "),n("code",[s._v("nums")]),s._v(" 中作为 "),n("strong",[s._v("摆动序列")]),s._v(" 的 "),n("strong",[s._v("最长子序列的长度")]),s._v(" 。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [1,7,4,9,2,5]\n输出：6\n解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：要求返回子序列中最长的摆动序列长度，则根据摆动序列的定义，记录数组中的波峰、波谷即可的最长序列长度。其中，数组两端各有一个波峰。有三种情况需要考虑：")]),s._v(" "),n("ul",[n("li",[s._v("上下有平坡 （preDiff == 0， cudDiff > || < 0)")]),s._v(" "),n("li",[s._v("首位元素    (两端记录)")]),s._v(" "),n("li",[s._v("单调有平坡。（preDiff只在有变动的地方更新）")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        if (nums.size() <= 1) return nums.size();\n        int preDiff = 0;    //前一个摆动\n        int curDiff = 0;    //当前摆动\n        int max = 1;        //摆动数量，由于数组两端默认有两个摆动，下方未计算数组末尾所以 max初始值为 1.\n        for(int i = 0; i < nums.size() - 1; ++i)\n        {\n            curDiff = nums[i + 1] - nums[i];\n            if((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0))\n            {\n                ++max;\n                preDiff = curDiff; //只在有摆动的地方更新pre，避免了单调有平坡时误加摆动数量。\n            }\n        }\n        return max;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("h3",{attrs:{id:"最大子数组和-leetcode-53"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最大子数组和-leetcode-53"}},[s._v("#")]),s._v(" 最大子数组和 leetcode 53")]),s._v(" "),n("p",[s._v("题目：给你一个整数数组 "),n("code",[s._v("nums")]),s._v(" ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。")]),s._v(" "),n("p",[n("strong",[s._v("子数组")]),s._v(" 是数组中的一个连续部分。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：要求的是连续子序例的最大和，所以一直遍历，"),n("strong",[s._v("每当当前连续和小于0了，则将当前连续和设为1从下一个数重新开始计数")]),s._v("，每当sum>result了更新result。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int result= INT32_MIN;\n        int sum = 0;\n        for(int i = 0; i < nums.size(); i++)\n        {\n            sum += nums[i];\n            if (sum > result)   result = sum;\n            if (sum <= 0)    sum = 0;\n        }\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])])])}),[],!1,null,null,null);n.default=t.exports}}]);