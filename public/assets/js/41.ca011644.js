(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{446:function(s,n,a){"use strict";a.r(n);var e=a(2),t=Object(e.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day36-贪心-part05"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day36-贪心-part05"}},[s._v("#")]),s._v(" Day36 贪心 part05")]),s._v(" "),n("h3",{attrs:{id:"贪心算法理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法理论基础"}},[s._v("#")]),s._v(" 贪心算法理论基础")]),s._v(" "),n("p",[s._v("贪心的本质是选择每一阶段的局部最优，从而达到全局最优。")]),s._v(" "),n("p",[n("strong",[s._v("贪心的使用：")])]),s._v(" "),n("p",[s._v("贪心没有固定的套路，验证能不能使用贪心最好的策略是举反例，"),n("strong",[s._v("刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心")])]),s._v(" "),n("p",[n("strong",[s._v("贪心的一般解题步骤：")])]),s._v(" "),n("ul",[n("li",[s._v("将问题分解为若干个子问题。")]),s._v(" "),n("li",[s._v("找出合适的贪心策略。")]),s._v(" "),n("li",[s._v("求解每一个子问题的最优解。")]),s._v(" "),n("li",[s._v("将局部最优解堆叠成全局最优解。")])]),s._v(" "),n("h3",{attrs:{id:"无重叠区间-leetcode-435"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#无重叠区间-leetcode-435"}},[s._v("#")]),s._v(" 无重叠区间 leetcode 435")]),s._v(" "),n("p",[s._v("题目：给定一个区间的集合 "),n("code",[s._v("intervals")]),s._v(" ，其中 "),n("code",[s._v("intervals[i] = [starti, endi]")]),s._v(" 。返回 "),n("em",[s._v("需要移除区间的最小数量，使剩余区间互不重叠")]),s._v(" 。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1:")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: intervals = [[1,2],[2,3],[3,4],[1,3]]\n输出: 1\n解释: 移除 [1,3] 后，剩下的区间没有重叠。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路： 让求需要删除几个区间才能不重叠，可以转换为求不交叉的区间数count，再用size（）- count即可。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    static bool cmp(vector<int>& a, vector<int>& b)\n    {\n        return a[1] < b[1];\n    }\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if(intervals.size() == 1)   return 0;\n        sort(intervals.begin(), intervals.end(), cmp);\n        int count = 1; \n        int end = intervals[0][1]; // 记录区间分割点\n        for (int i = 1; i < intervals.size(); i++) {\n            if (end <= intervals[i][0]) {\n                end = intervals[i][1];\n                count++;\n            }\n        }\n        return intervals.size() - count;\n    }\n};\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br")])]),n("h3",{attrs:{id:"划分字母区间-leetcode-763"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#划分字母区间-leetcode-763"}},[s._v("#")]),s._v(" 划分字母区间 leetcode 763")]),s._v(" "),n("p",[s._v("题目：给你一个字符串 "),n("code",[s._v("s")]),s._v(" 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。")]),s._v(" "),n("p",[s._v("注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 "),n("code",[s._v("s")]),s._v(" 。")]),s._v(" "),n("p",[s._v("返回一个表示每个字符串片段的长度的列表。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('输入：s = "ababcbacadefegdehijhklij"\n输出：[9,7,8]\n解释：\n划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。\n每个字母最多出现在一个片段中。\n像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 \n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("思路：妙蛙种子吃了妙脆角。 先遍历使用哈希法统计每个字符出现的最后位置，然后再一直遍历直到当前序列内包含的所有字符的最后出现位置处切割。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        int hash[27] = {0};\n        for (int i = 0; i < s.size(); ++i)\n        {\n            hash[s[i] - 'a'] = i;   //统计每个字符最后出现的位置\n        }\n\n        vector<int> result;\n        int left = 0;\n        int right = 0;\n\n        for (int i = 0; i < s.size(); ++i)\n        {\n            right = max(right, hash[s[i] - 'a']);\n            if (i == right) {\n                result.push_back(right - left + 1);\n                left = i + 1;\n            }\n        }\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br")])]),n("h3",{attrs:{id:"合并区间-leetcode-56"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合并区间-leetcode-56"}},[s._v("#")]),s._v(" 合并区间 leetcode 56")]),s._v(" "),n("p",[s._v("题目：以数组 "),n("code",[s._v("intervals")]),s._v(" 表示若干个区间的集合，其中单个区间为 "),n("code",[s._v("intervals[i] = [starti, endi]")]),s._v(" 。请你合并所有重叠的区间，并返回 "),n("em",[s._v("一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间")]),s._v(" 。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[s._v("思路：和前面的一样，主要是怎么判断重叠。 lambda表达式知道但不熟悉，需要看看。")]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        vector<vector<int>> result;\n        if (intervals.size() == 0)  return result;\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0];}); //lambda表达式法。\n\n        result.push_back(intervals[0]); //将首个元素放入，后边直接判断合并\n        for (int i = 1; i < intervals.size(); ++i)\n        {\n            if (result.back()[1] >= intervals[i][0])    //如果重叠 右区间大于左区间\n            {\n                 // 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值（左边界排序的）\n                result.back()[1] = max(result.back()[1], intervals[i][1]);\n            }\n            else\n            {\n                result.push_back(intervals[i]); //不重叠则压入当前区间，进行下一次循环判断\n            }\n        }\n        return result;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br")])])])}),[],!1,null,null,null);n.default=t.exports}}]);