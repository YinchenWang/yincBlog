(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{451:function(s,n,t){"use strict";t.r(n);var a=t(2),i=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day42-动态规划part04"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day42-动态规划part04"}},[s._v("#")]),s._v(" Day42 动态规划part04")]),s._v(" "),n("h3",{attrs:{id:"动态规划理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态规划理论基础"}},[s._v("#")]),s._v(" 动态规划理论基础")]),s._v(" "),n("p",[n("strong",[s._v("背包问题：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png",alt:""}})]),s._v(" "),n("p",[n("strong",[s._v("01背包：")])]),s._v(" "),n("p",[s._v("有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。"),n("strong",[s._v("每件物品只能用一次")]),s._v("，求解将哪些物品装入背包里物品价值总和最大。")]),s._v(" "),n("p",[s._v("背包最大重量为4。")]),s._v(" "),n("p",[s._v("物品为：")]),s._v(" "),n("table",[n("thead",[n("tr",[n("th"),s._v(" "),n("th",[s._v("重量")]),s._v(" "),n("th",[s._v("价值")])])]),s._v(" "),n("tbody",[n("tr",[n("td",[s._v("物品0")]),s._v(" "),n("td",[s._v("1")]),s._v(" "),n("td",[s._v("15")])]),s._v(" "),n("tr",[n("td",[s._v("物品1")]),s._v(" "),n("td",[s._v("3")]),s._v(" "),n("td",[s._v("20")])]),s._v(" "),n("tr",[n("td",[s._v("物品2")]),s._v(" "),n("td",[s._v("4")]),s._v(" "),n("td",[s._v("30")])])])]),s._v(" "),n("p",[n("strong",[s._v("暴力解法:")])]),s._v(" "),n("p",[s._v("使用暴力解法就是使用回溯法搜索出所有的情况。时间复杂度为指数级 $O(2^n)$, n为物品数量。")]),s._v(" "),n("p",[n("strong",[s._v("二维DP数组解01背包:")])]),s._v(" "),n("ul",[n("li",[n("p",[s._v("确定DP数组以及下标含义：d"),n("strong",[s._v("p[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少")]),s._v("。"),n("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png",alt:""}})])]),s._v(" "),n("li",[n("p",[s._v("确定递推公式：")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("**不放物品 i: ** 由dp[i -1] [j]推出，背包容量为 j， 里面不放物品 i 的最大价值，此刻dp[i] [j] 就是dp[i -1] [j].")])]),s._v(" "),n("li",[n("p",[n("strong",[s._v("放物品 i")]),s._v(" 由dp[i -1] [j - weight[i]]推出，dp[i -1] [j - weight[i]]为背包容量为 j - weight[i]时不放物品 i 的最大价值，所以加上物品 i 的价值就是背包放入物品 i 的价值，为 ：dp[i -1] [j - weight[i]] + value[i]。")]),s._v(" "),n("p",[s._v("因此，递推公式为：")]),s._v(" "),n("p",[n("strong",[s._v("dp[i] [j] = max (dp[i - 1] [j] , dp[i -1] [j - weight[i]] + value[i])")])])])])]),s._v(" "),n("li",[n("p",[s._v("DP数组初始化:")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("背包容量为0 则总和一定为0，所以：")])]),s._v(" "),n("li",[n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  for (int j = 0 ; j &lt; weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。\n      dp[0][j] = 0;\n  }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("当j < weight[0]时，dp[0] [j] = 0, 当j >= weight[0]时，dp[0] [j] = value[0].")])]),s._v(" "),n("li",[n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  for (int j = weight[0]; j &lt;= bagweight; j++) {\n      dp[0][j] = value[0];\n  }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])])])])]),s._v(" "),n("li",[n("p",[s._v("确定遍历顺序:    二维情况可以颠倒, 正序倒序都可")])]),s._v(" "),n("li",[n("p",[s._v("打印DP数组： 用于debug")])])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    void problem_2d_bag () {\n      vector<int> weight = {1, 3, 4};\n      vector<int> value = {15, 20, 30};\n      int bagWeight = 4;\n      \n      vector<vector<int>> dp(weight.size(), vector<int>(bagWeight + 1, 0));\n      //初始化\n      for (int j = weight[0]; j <= bagWeight; j++) {\n        dp[0][j] = value[0];\n      }\n      \n      for(int i = 1; i < weight.size(); i++) { // 遍历物品\n        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量\n            if (j < weight[i]) dp[i][j] = dp[i - 1][j];\n            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n\n        }\n    }\n\n    cout << dp[weight.size() - 1][bagWeight] << endl;\n      \n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br")])]),n("p",[n("strong",[s._v("一维DP数组解01背包问题：")])]),s._v(" "),n("p",[s._v("在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);")]),s._v(" "),n("p",[n("strong",[s._v("其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);")])]),s._v(" "),n("p",[n("strong",[s._v("与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了")]),s._v("，只用dp[j]（一维数组，也可以理解是一个滚动数组）。")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("确定DP数组以及下标含义：dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。")])]),s._v(" "),n("li",[n("p",[s._v("确定递推公式： dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);")])]),s._v(" "),n("li",[n("p",[s._v("DP数组初始化:")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("dp[0] = 0：")])]),s._v(" "),n("li",[n("p",[s._v("dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了")])]),s._v(" "),n("li",[n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品\n      for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量\n          dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n  \n      }\n  }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])])])]),s._v(" "),n("li",[n("p",[s._v("确定遍历顺序:    必须逆序遍历！！"),n("strong",[s._v("为了保证物品i只被放入一次")])])]),s._v(" "),n("li",[n("p",[s._v("打印DP数组： 用于debug")])])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("void test_1_wei_bag_problem() {\n    vector<int> weight = {1, 3, 4};\n    vector<int> value = {15, 20, 30};\n    int bagWeight = 4;\n\n    // 初始化\n    vector<int> dp(bagWeight + 1, 0);\n    for(int i = 0; i < weight.size(); i++) { // 遍历物品\n        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量\n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n        }\n    }\n    cout << dp[bagWeight] << endl;\n}\n\nint main() {\n    test_1_wei_bag_problem();\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br")])]),n("h3",{attrs:{id:"分割等和子集-leetcode-416"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分割等和子集-leetcode-416"}},[s._v("#")]),s._v(" 分割等和子集 leetcode 416")]),s._v(" "),n("p",[s._v("题目：给你一个 "),n("strong",[s._v("只包含正整数")]),s._v(" 的 "),n("strong",[s._v("非空")]),s._v(" 数组 "),n("code",[s._v("nums")]),s._v(" 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。")]),s._v(" "),n("p",[s._v("（背包应用类题目）")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("示例 2：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("提示：")])]),s._v(" "),n("ul",[n("li",[n("code",[s._v("1 <= nums.length <= 200")])]),s._v(" "),n("li",[n("code",[s._v("1 <= nums[i] <= 100")])])]),s._v(" "),n("p",[s._v("思路：")]),s._v(" "),n("ul",[n("li",[s._v("确定DP数组以及下标含义： 容量为 j ，它的价值是dp[j]。 Dp[target] == target时，背包装满了。 本题为target =  sum / 2。")]),s._v(" "),n("li",[s._v("确定递推公式：dp[j] = max(dp[j],  dp[j - nums[i]] + nums[i])。 // 01背包")]),s._v(" "),n("li",[s._v("DP数组初始化:   dp[0] = 0, 其他也为0 。")]),s._v(" "),n("li",[s._v("确定遍历顺序:    从后往前遍历")]),s._v(" "),n("li",[s._v("打印DP数组： 用于debug")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\nprivate:\n    int getTarget(vector<int>& nums)\n    {\n        int sum = 0;\n        for( int i : nums)\n        {\n            sum += i;\n        }\n        if (sum % 2 == 1)   return -1;\n        return sum / 2;\n    }\npublic:\n    bool canPartition(vector<int>& nums) {\n        int target = getTarget(nums);\n        if (target == -1)   return false;\n        vector<int> dp(10001, 0);\n\n        for (int i = 0; i < nums.size(); ++i)\n        {\n            for (int j = target; j >= nums[i]; --j)\n            {\n                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n        }\n\n        // 集合中的元素正好可以凑成总和target\n        if (dp[target] == target) return true;\n        return false;\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br")])])])}),[],!1,null,null,null);n.default=i.exports}}]);