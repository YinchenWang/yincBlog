(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{462:function(s,n,e){"use strict";e.r(n);var t=e(2),a=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"day48-动态规划part09"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day48-动态规划part09"}},[s._v("#")]),s._v(" Day48 动态规划part09")]),s._v(" "),n("h3",{attrs:{id:"动态规划理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态规划理论基础"}},[s._v("#")]),s._v(" 动态规划理论基础")]),s._v(" "),n("p",[n("strong",[s._v("背包问题：")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png",alt:""}})]),s._v(" "),n("p",[n("strong",[s._v("多重背包：")])]),s._v(" "),n("p",[s._v("展开成为01背包")]),s._v(" "),n("h3",{attrs:{id:"打家劫舍-leetcode-198"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打家劫舍-leetcode-198"}},[s._v("#")]),s._v(" 打家劫舍 leetcode 198")]),s._v(" "),n("p",[s._v("题目：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，"),n("strong",[s._v("如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警")]),s._v("。")]),s._v(" "),n("p",[s._v("给定一个代表每个房屋存放金额的非负整数数组，计算你 "),n("strong",[s._v("不触动警报装置的情况下")]),s._v(" ，一夜之内能够偷窃到的最高金额。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：[1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[n("strong",[s._v("示例 2：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：[2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[n("strong",[s._v("提示：")])]),s._v(" "),n("ul",[n("li",[n("code",[s._v("1 <= nums.length <= 100")])]),s._v(" "),n("li",[n("code",[s._v("0 <= nums[i] <= 400")])])]),s._v(" "),n("p",[s._v("思路：")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("确定DP数组以及下标含义：考虑下标 i（包含）， 能偷到的最大的金额为dp[i]。")])]),s._v(" "),n("li",[n("p",[s._v("确定递推公式：对于i来说")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("偷 i :\t则dp[i - 2] + nums[i]")])]),s._v(" "),n("li",[n("p",[s._v("不偷 i： 则dp[i -1]")]),s._v(" "),n("p",[s._v("因此 dp[i] = max( (dp[i - 2] + nume[i]), dp[i - 1])")])])])]),s._v(" "),n("li",[n("p",[s._v("DP数组初始化:   dp[0] = numi[i],     dp[1] = max(nums[0], nums[1])")])]),s._v(" "),n("li",[n("p",[s._v("确定遍历顺序:    从小到大")])]),s._v(" "),n("li",[n("p",[s._v("打印DP数组： 用于debug")])])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        if (nums.size() == 1) return nums[0];\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.size(); ++i)\n        {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n        return dp[nums.size() - 1];\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br")])]),n("h3",{attrs:{id:"打家劫舍ii-leetcode-213"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打家劫舍ii-leetcode-213"}},[s._v("#")]),s._v(" 打家劫舍II leetcode 213")]),s._v(" "),n("p",[s._v("题目：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 "),n("strong",[s._v("围成一圈")]),s._v(" ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，"),n("strong",[s._v("如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警")]),s._v(" 。")]),s._v(" "),n("p",[s._v("给定一个代表每个房屋存放金额的非负整数数组，计算你 "),n("strong",[s._v("在不触动警报装置的情况下")]),s._v(" ，今晚能够偷窃到的最高金额。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [2,3,2]\n输出：3\n解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("示例 2：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[n("strong",[s._v("示例 3：")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入：nums = [1,2,3]\n输出：3\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("strong",[s._v("提示：")])]),s._v(" "),n("ul",[n("li",[n("code",[s._v("1 <= nums.length <= 100")])]),s._v(" "),n("li",[n("code",[s._v("0 <= nums[i] <= 1000")])])]),s._v(" "),n("p",[s._v("思路：主要处理头尾两个元素，选头去尾或者选尾去头考虑即可，其余和打家劫舍I相同")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("确定DP数组以及下标含义：考虑下标 i（包含）， 能偷到的最大的金额为dp[i]。")])]),s._v(" "),n("li",[n("p",[s._v("确定递推公式：对于i来说")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("偷 i :\t则dp[i - 2] + nums[i]")])]),s._v(" "),n("li",[n("p",[s._v("不偷 i： 则dp[i -1]")]),s._v(" "),n("p",[s._v("因此 dp[i] = max( (dp[i - 2] + nume[i]), dp[i - 1])")])])])]),s._v(" "),n("li",[n("p",[s._v("DP数组初始化:   dp[0] = numi[i],     dp[1] = max(nums[0], nums[1])")])]),s._v(" "),n("li",[n("p",[s._v("确定遍历顺序:    从小到大")])]),s._v(" "),n("li",[n("p",[s._v("打印DP数组： 用于debug")])])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("int rob(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        if (nums.size() == 1) return nums[0];\n        int result1 = robRange(nums, 0, nums.size() - 2); // 选头去尾\n        int result2 = robRange(nums, 1, nums.size() - 1); // 选尾去头\n        return max(result1, result2);\n    }\n    // 198.打家劫舍的逻辑\n    int robRange(vector<int>& nums, int start, int end) {\n        if (end == start) return nums[start];\n        vector<int> dp(nums.size());\n        dp[start] = nums[start];\n        dp[start + 1] = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[end];\n    }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br")])]),n("h3",{attrs:{id:"打家劫舍iii-leetcode-337"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打家劫舍iii-leetcode-337"}},[s._v("#")]),s._v(" 打家劫舍III leetcode 337")]),s._v(" "),n("p",[s._v("题目：小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 "),n("code",[s._v("root")]),s._v(" 。")]),s._v(" "),n("p",[s._v("除了 "),n("code",[s._v("root")]),s._v(" 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 "),n("strong",[s._v("两个直接相连的房子在同一天晚上被打劫")]),s._v(" ，房屋将自动报警。")]),s._v(" "),n("p",[s._v("给定二叉树的 "),n("code",[s._v("root")]),s._v(" 。返回 "),n("em",[n("strong",[s._v("在不触动警报的情况下")]),s._v(" ，小偷能够盗取的最高金额")]),s._v(" 。")]),s._v(" "),n("p",[n("strong",[s._v("示例 1:")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: root = [3,2,3,null,3,null,1]\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("示例 2:")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg",alt:"img"}})]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("输入: root = [3,4,5,1,3,null,1]\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br")])]),n("p",[n("strong",[s._v("提示：")])]),s._v(" "),n("ul",[n("li",[s._v("树的节点数在 "),n("code",[s._v("[1, 104]")]),s._v(" 范围内")]),s._v(" "),n("li",[n("code",[s._v("0 <= Node.val <= 104")])])]),s._v(" "),n("p",[s._v("思路：")]),s._v(" "),n("ul",[n("li",[s._v("确定DP数组以及下标含义：因为递归 所以只需要一个长度为2的数组即可\n"),n("ul",[n("li",[s._v("dp[0]表示不偷当前节点的最大金额")]),s._v(" "),n("li",[s._v("dp[1]表示偷当前节点的最大金额")])])]),s._v(" "),n("li",[s._v("递归终止条件")])]),s._v(" "),n("div",{staticClass:"language-c++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("if (cur == NULL) return vector<int>{0, 0};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("ul",[n("li",[s._v("确定遍历顺序:    后序遍历")]),s._v(" "),n("li",[s._v("打印DP数组： 用于debug")])]),s._v(" "),n("div",{staticClass:"language-C++ line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        vector<int> result = robTree(root);\n        return max(result[0], result[1]);\n    }\n    // dp长度为2的数组，0：不偷，1：偷 递归\n    vector<int> robTree(TreeNode* cur) {\n        if (cur == NULL) return vector<int>{0, 0};\n        vector<int> left = robTree(cur->left);\n        vector<int> right = robTree(cur->right);\n        // 偷cur，那么就不能偷左右节点。\n        int val1 = cur->val + left[0] + right[0];\n        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况\n        int val2 = max(left[0], left[1]) + max(right[0], right[1]);\n        return {val2, val1};\n    }\n};\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])])])}),[],!1,null,null,null);n.default=a.exports}}]);